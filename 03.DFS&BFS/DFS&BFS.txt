1.스택 Stack
= 박스 쌓기
-선입후출 First In Last Out or 후입선출 Last In First Out
 별도의 라이브러리 사용X
 stack = [] 기본 리스트에서 append()와 pop() 메서드 이용

2.큐 Queue
= 대기 줄 (공정한 자료구조)
-선입선출 First In First Out
 colloections 모듈에서 제공하는 deque 자료구조 활용
 From collections import deque
 queue = deque()
 deque 객체를 리스트로 변경 -> list() 이용 list(queue)

3.재귀함수 Recursive Function
:자기 자신을 다시 호출하는 함수
 *종료 조건을 꼭 명시해야함
 (재귀 함수는 내부적으로 스택 자료구조와 동일함)
-재귀 함수 VS 반복문
 재귀 함수의 코드가 더 간결함

4.DFS(Depth-First Search) 깊이 우선 탐색
:그래프에서 깊은 부분을 우선으로 탐색하는 알고리즘
 특정한 경로로 탐색하다 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘
 [동작 과정]
 1)참색 시작 노드를 스택에 삽입하고 방문 처리
 2)스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리
   방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드 꺼냄
 3)2번의 과정을 더 이상 수행할 수 없을 때까지 반복

<프로그래밍에서 그래프를 표현하는 방식 2가지>
1.인접 행렬 Adjacency Matrix 방식
  :2차원 배열에 각 노드가 연결된 형태를 기록하는 방식
  2차원 리스트로 구현
2.인접 리스트 Adjacency List 방식
  :모든 노드에 연결된 노드에 대한 정보를 차례대로 연결해 저장
  2차원 리스트로 구현
 [인접 행렬 VS 인접 리스트]
  -인접 행렬: 모든 관계를 저장하므로 노드 개수가 많을수록 메모리 불필요하게 낭비
  +인접 리스트: 연결된 정보만을 저장하기에 메모리 효율적으로 사용
  -인접 리스트: 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도 느림

5.BFS(Breadth First Search) 너비 우선 탐색
:가까운 노드부터 탐색하는 알고리즘
 큐 자료구조 이용(선입선출)
 인접한 노드를 반복적으로 큐에 넣도록 알고리즘 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어, 가까운 노트부터 탐색 진행
 [동작 과정]
 1)탐색 시작 노드를 큐에 삽입하고 방문 처리
 2)큐에서 노드 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
 3)2번의 과정 더 이상 수행할 수 없을 때까지 반복

==> 2차원 배열에서의 탐색 문제 -> DFS와 BFS 문제 유형일 수 있음
    -> 그래프 형태로 바꿔서 생각하면 풀이 방법을 좀 더 쉽게 떠올릴 수 있음
